module;

#include <filesystem>
#include <algorithm>
#include <iostream>
#include <fstream>
#include <sstream>

export module App;
export import :hash;
import :options;

namespace app {
  namespace fs = std::filesystem;

  struct Hash {
    Hash() = default;

    Hash(const sha::v1::Hash& hash,
         const std::string& filename,
         bool tag,
         std::ios_base::openmode openmode,
         char ending)
      : hash{hash},
        filename{filename},
        tag{tag},
        openmode{openmode},
        ending{ending} {}

    friend std::ostream& operator<<(std::ostream&, const Hash&);
    friend std::istream& operator>>(std::istream&, Hash&);

    sha::v1::Hash hash;
    std::string filename;
    bool tag;
    std::ios_base::openmode openmode;
    char ending;
  };

  std::ostream& operator<<(std::ostream& os, const Hash& it) {
    auto& hash = it.hash;
    auto& filename = it.filename;
    bool tag = it.tag;
    auto& openmode = it.openmode;
    char ending = it.ending;
    if (!tag)
      os << hash
         << (openmode & std::ios_base::binary ? " *" : "  ") << filename
         << ending;
    else
      os << "SHA1 (" << filename << ") = "
         << hash
         << ending;
    return os;
  }

  void skipws(std::istream& is) {
    if (!is)
      return;
    char ch;
    is >> std::skipws >> ch;
    is.unget();
  }

  std::istream& operator>>(std::istream& is, Hash& it) {
    istream::Fail fail{is};

    auto& hash = it.hash;
    auto& filename = it.filename;
    auto& tag = it.tag;
    auto& openmode = it.openmode;
    auto& ending = it.ending;

    std::string str;

    is >> str;
    if (!is)
      return fail();

    tag = str == "SHA1";
    if (tag) {
      openmode = std::ios_base::in | std::ios_base::binary;
      is >> str;
      if (!is || str.front() != '(' || str.back() != ')')
        return fail();
      filename = std::string{std::next(str.begin()), std::prev(str.end())};
      is >> str;
      if (!is || str.front() != '=')
        return fail();
      is >> hash;
      if (is.fail())
        return is;
    } else {
      std::istringstream istr{str};
      istr >> hash;
      if (istr.fail())
        return fail();
      is >> filename;
      openmode = (filename[0] == '*' && !fs::exists(filename)
                  ? std::ios_base::in | std::ios_base::binary
                  : std::ios_base::in);
      if ((openmode & std::ios_base::binary) && filename[0] == '*')
        filename.erase(0, 1);
    }

    ending = is.get();
    return is;
  }

  int verify(Options& options) {
    for (auto& filename : options.filenames) {
      std::ifstream input{filename};
      while (skipws(input), input) {
        Hash hash;
        input >> hash;

        if (input.fail()) {
          std::string line;
          input.clear();
          std::getline(input, line);
          std::cerr << line << ": FAILED to parse" << std::endl;
          continue;
        }

        const auto& filename = hash.filename;
        const auto& openmode = hash.openmode;
        std::ifstream is{filename, openmode};

        if (!is.good()) {
          std::cerr << filename << ": FAILED open or read" << std::endl;
          continue;
        }

        const auto& shav1_hash = sha::v1::hash(is);
        std::cout << filename << ": " << (shav1_hash == hash.hash ? "OK" : "FAILED") << std::endl;
      }
    }
    return 0;
  }

  template <Standard>
  struct SHA;

  template <>
  struct SHA<k1> {
    using Hash = sha::v1::Hash;
    constexpr static Standard std = k1;
    constexpr static auto function = [](auto&&... args) { return sha::v1::hash(args...); };
  };

  template <>
  struct SHA<k224> {
    using Hash = sha::v224::Hash;
    constexpr static Standard std = k224;
    constexpr static auto function = [](auto&&... args) { return sha::v224::hash(args...); };
  };

  template <>
  struct SHA<k256> {
    using Hash = sha::v256::Hash;
    constexpr static Standard std = k256;
    constexpr static auto function = [](auto&&... args) { return sha::v256::hash(args...); };
  };

  template <>
  struct SHA<k384> {
    using Hash = sha::v384::Hash;
    constexpr static Standard std = k384;
    constexpr static auto function = [](auto&&... args) { return sha::v384::hash(args...); };
  };

  template <>
  struct SHA<k512> {
    using Hash = sha::v512::Hash;
    constexpr static Standard std = k512;
    constexpr static auto function = [](auto&&... args) { return sha::v512::hash(args...); };
  };

  template <>
  struct SHA<k512_224> {
    using Hash = sha::v512_224::Hash;
    constexpr static Standard std = k512_224;
    constexpr static auto function = [](auto&&... args) { return sha::v512_224::hash(args...); };
  };

  template <>
  struct SHA<k512_256> {
    using Hash = sha::v512_256::Hash;
    constexpr static Standard std = k512_256;
    constexpr static auto function = [](auto&&... args) { return sha::v512_256::hash(args...); };
  };

  template <Standard std>
  struct Format {
    Format(const SHA<std>::Hash& hash,
           const std::string& file,
           bool tag,
           const Mode& mode,
           char ending)
      : hash{hash},
        file{file},
        tag{tag},
        mode{mode},
        ending{ending} {}

    friend std::ostream& operator<<(std::ostream& output, const Format<std>& format) {
      auto& hash = format.hash;
      auto& file = format.file;
      bool tag = format.tag;
      auto& mode = format.mode;
      char ending = format.ending;
      if (!tag)
        output << hash
               << (mode == kBinary ? " *" : "  ") << file
               << ending;
      else
        output << "SHA" << std
               << " (" << file << ") = "
               << hash
               << ending;
      return output;
    }

    friend std::istream& operator>>(std::istream& input, Format<std>& format) {
      istream::Fail fail{input};

      auto& hash = format.hash;
      auto& file = format.file;
      auto& tag = format.tag;
      auto& mode = format.mode;
      auto& ending = format.ending;

      std::string buffer;

      if (input >> buffer, buffer.empty()) return fail();

      tag = buffer == "SHA" + to_string(std);
      if (tag) {
        mode = kBinary;
        if (input >> file,
            file.empty()
            || (file.front() != '(' || file.back() != ')')) return fail();

        file.erase(file.begin());
        file.erase(file.end());

        if (input >> buffer,
            buffer.empty() || buffer != "=") return fail();
        if (input >> hash, input.fail()) return fail();
      } else {
        std::istringstream hash_input{buffer};
        if (hash_input >> hash, hash_input.fail()) return fail();
        if (input >> file, file.empty()) return fail();
        mode = file.front() == '*' && !fs::exists(file) ? kBinary : kText;
        if (mode == kBinary)
          file.erase(file.begin());
      }

      return input;
    }

    SHA<std>::Hash hash;
    std::string file;
    bool tag;
    Mode mode;
    char ending;
  };

  template <Standard std>
  int print(Options& options) {
    const auto& mode = options.mode;
    const bool zero = options.zero;
    const bool tag = options.tag;
    const std::ios_base::openmode openmode = (mode == kBinary || tag
                                              ? std::ios_base::in | std::ios_base::binary
                                              : std::ios_base::in);

    for (auto& filename : options.filenames) {
      const auto& hash = SHA<std>::function(std::ifstream{filename, openmode});
      std::cout << Format<std>{hash, filename, tag, mode, zero ? '\0' : '\n'};
    }

    return 0;
  }

  int print(Options& options) {
    const auto std = options.std;
    switch (std) {
    case k1: return print<k1>(options);
    case k224: return print<k224>(options);
    case k256: return print<k256>(options);
    case k384: return print<k384>(options);
    case k512: return print<k512>(options);
    case k512_224: return print<k512_224>(options);
    case k512_256: return print<k512_256>(options);
    }
    throw std::invalid_argument{"unsupported standard " + std::to_string(std)};
  }

  export int run(int argc, char* argv[]) {
    Options options = parse(argc, argv);

    if (options.ignore)
      return options.success ? 0 : -1;

    const bool check = options.check;
    return !check ? print(options) : verify(options);
  }
}
